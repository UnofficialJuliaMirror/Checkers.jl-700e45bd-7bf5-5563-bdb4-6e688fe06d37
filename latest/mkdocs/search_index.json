{
    "docs": [
        {
            "location": "/", 
            "text": "Checkers \ud83c\udfc1 \ud83c\udfc1 Documentation\n\n\n\n\nIntroduction\n\n\nAutomated testing macros inspired by a \nJulia implementation\n of Koen Claessen and John Hughes' \nQuickCheck\n property-based randomized tester.\n\n\nCheckers lets you write quick property-based tests:\n\n\njulia\n using Checkers\njulia\n f(x) = x^2\njulia\n @test_formany -10\nx\n10, f(x) \n= 0\nTest Passed\n  Expression: (:((-10 \n x \n 10, f(x) \n= 0)), :(mode = test_formany))\n\njulia\n @test_forall x in -10:10, f(x) \n= 0\nTest Passed\n  Expression: (x in -10:10, f(x) \n= 0)\n    @test_forall x in 0:10, f(x) \n= 0\n\njulia\n @test_forall x in -10:10, f(x) \n 0 #Should fail b/c f(0) = 0\nTest Failed\n  Expression: (x in -10:10, f(x) \n 0)\nERROR: There was an error during testing\n\n\n\n\n\n\n\nQuickstart Guide\n\n\nThis package provides three macros for test generation:\n\n\n\n\n@test_forall\n\n\n@test_formany\n\n\n@test_exists\n\n\n\n\nIn each case, the basic format is\n\n\n@[test] [set of values to test] [property to test]\n\n\n\n\n\nThe \nproperty\n is any expression that evaluates to a boolean, making reference to some dummy variable specified in the set of values to test.\n\n\nThe macros differ in how they specify and choose values to test:\n\n\n\n\nUse \n@test_forall\n when you can specify the exact \nfinite set\n of values to  test.  For example, \n-3:3\n specifies the exact set of 7 Int64 values, {-3,-2,-1,0,1,2,3}, on which you wish to test the property. Because the user specifies the test universe completely, and that universe is finite, every value is tested and @test_forall returns only true positives and true negatives.\n\n\nUse \n@test_formany\n when you wish to specify a (possibly infinite) set of values  to test by restricted comprehension from some universe.  For example, \n-3 \n x::Float64 \n 3\n specifies that some number of \nFloat64\ns \nx\n, satisfying the condition \n-3 \n x \n 3\n, will be tested for the property. Note that \n@test_formany\n is meant to capture the idea of the universal  quantifier, but is not universal on infinite sets,  since the package will only run a finite number of tests. That is, \n@test_formany\n may return a false positive, as it cannot be comprehensive. It will not, however, return a false negative.\n\n\nUse \n@test_exists\n like \n@test_formany\n, but when you wish the test to pass when  at least one value satisfies the property, rather than when all tested values satisfy the property. Like \n@test_formany\n, \n@test_exists\n \nsimulates\n the existential quantifier, but is not strictly speaking complete.  That is, \n@test_exists\n may return a false negative, in the case that a value exists but was not lucky enough to be tested. It will not, however, return a false positive.\n\n\n\n\n\n\nThe Macros in More Detail\n\n\n@test_forall\n takes an expression specifying one or more dummy variables, discrete sets of values for those variables, and an expression, and tests the expression substituting every combination of the variables  (the Cartesian product of their possible value sets).  (Since Julia 0.5, \n@test_forall x in [Collection], P(x)\n is quite similar to  \n@test for x in [Collection] P(x) end\n, and we may deprecate / remove it for that reason.)\n\n\nThe property may be a conditional expression such as \nP(x) --\n Q(x)\n, in which case truth may be vacuous when \nP(x)\n is false \n\\forall x\n tested.\n\n\n@test_formany\n functions like \n@test_forall\n, but allows quantifying over infinite sets such as \n[a,b] \\subset \\mathbb R\n, etc. by sampling these sets uniformly at random. It provides additional modifiers to control how many tests it runs, which are especially helpful for ensuring that conditional-expression tests are not only passed vacuously.\n\n\n@test_exists X\n is essentially shorthand for \n! (@test_formany !X)\n.\n\n\n\n\nExhaustion\n\n\nNote that \n@test_formany\n and \n@test_exists\n are not strictly speaking exhaustive or true universal/existential quantifiers. \n@test_formany x Expr(x)\n may pass even when \n\\exists x\n s.t. \nExpr(x)\n is false, and \n@test_exists x Expr(x)\n may fail even under the same circumstances. However, \n@test_forall\n is exhaustive.\n\n\nTests that do not exhaust their universe take additional keyword arguments  \nntests\n and \nmaxtests\n to control how many tests to run.\n\n\n\n\nExamples\n\n\nBasic usage:\n\n\n@test_forall  x in 1:5,  x^2 \n 30\n@test_formany 1 \n x \n 5, x^2 \n 30\n@test_exists  1 \n x \n 5, x^2 \n 30\n\n\n\n\n\nControl how many tests in \n@test_formany\n:\n\n\n@test_formany ntests = 10_000  1 \n x \n 5, x^2 \n 30\n\n\n\n\n\nTest a conditional property, passing only if 100 of the tests are not vacuous:\n\n\n@test_formany ntests = 100  0 \n x \n Inf, 0 \n y \n Inf,  x \n y --\n log(x)\nlog(y)\n\n\n\n\n\nTest a conditional property, passing only if 100 of the tests are not vacuous, but only allow 100 tests:\n\n\n@test_formany ntests = 100 maxtests = 100  0 \n x \n 10,  0 \n y \n 10,  x \n y --\n x^2 \n y^2\n\n\n\n\n\nTest a conditional property, passing only if 100 of the test are not vacuous, but allow 100,000 tests:\n\n\n@test_formany ntests = 100 maxtests = 100_000 0 \n x \n 10,  0 \n y \n 10,  x \n y --\n x^2 \n y^2\n\n\n\n\n\nNote that while the former (\nmaxtests=100\n) usually fails, the latter (\nmaxtests=100_000\n) passes.  This is because \n@test_formany\n generates 100 random pairs of \n(x,y)\n, but not all of them are likely to satisfy \nx \n y\n. Therefore when \nmaxtests=100\n, it will not generate enough pairs to test the consequent of the conditional expression.\n\n\nSee \n?@test_forall\n, etc. and \nexamples/examples.jl\n for more detailed information. \n\n\n\n\nLogging\n\n\nTest logging is available in \n@test_formany\n to see which values were actually tested by using the keyword \nlogto\n and supplying an output path:\n\n\n@test_formany logto = \ntests.csv\n 1\nx\n5, x^2 \n 30\n\n\n\n\n\n\n\nOutput\n\n\nTest macros output results of type \nBase.Test.Pass\n, \nBase.Test.Fail\n,  or \nBase.Test.Error\n in order to function seamlessly with \nBase.Test.@testset\n.\n\n\n@testset \nMultiple tests\n begin \n    @test_forall x in 1:5, x^2 \n 30\n    @test_forall x in 1:6, x^2 \n 30\nend\n\n\n\n\n\n\n\nSee Also\n\n\nAlso of note are these more comprehensive (and we feel complicated) packages.  Our goal is to provide a lightweight, ready-to-use out-of-the-box alternative:\n\n\n\n\nBaseTestAuto\n\n\nDataGenerators\n\n\n\n\n\n\nLicense\n\n\nThe Checkers.jl package is licensed under the MIT \"Expat\" License:\n\n\nCopyright (c) 2017: Efim Abrikosov \n Philip Kalikman.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nCredits\n\n\nThis package was co-designed and co-written by  \nEfim Abrikosov\n and  \nPhilip Kalikman\n while each was a graduate student at Yale University.\n\n\n\n\nEfim wrote the majority of the code, which is based on but does not directly use \nthe work of Patrick O'Leary\n\n\nPhilip designed the majority of the functionality and syntax, building on \nthe work (in Haskell) of Koen Classen and John Hughes\n\n\n\n\n\n\nIndex\n\n\n\n\nCheckers.@test_exists\n\n\nCheckers.@test_forall\n\n\nCheckers.@test_formany", 
            "title": "Home"
        }, 
        {
            "location": "/#checkers-documentation", 
            "text": "", 
            "title": "Checkers \ud83c\udfc1 \ud83c\udfc1 Documentation"
        }, 
        {
            "location": "/#introduction", 
            "text": "Automated testing macros inspired by a  Julia implementation  of Koen Claessen and John Hughes'  QuickCheck  property-based randomized tester.  Checkers lets you write quick property-based tests:  julia  using Checkers\njulia  f(x) = x^2\njulia  @test_formany -10 x 10, f(x)  = 0\nTest Passed\n  Expression: (:((-10   x   10, f(x)  = 0)), :(mode = test_formany))\n\njulia  @test_forall x in -10:10, f(x)  = 0\nTest Passed\n  Expression: (x in -10:10, f(x)  = 0)\n    @test_forall x in 0:10, f(x)  = 0\n\njulia  @test_forall x in -10:10, f(x)   0 #Should fail b/c f(0) = 0\nTest Failed\n  Expression: (x in -10:10, f(x)   0)\nERROR: There was an error during testing", 
            "title": "Introduction"
        }, 
        {
            "location": "/#quickstart-guide", 
            "text": "This package provides three macros for test generation:   @test_forall  @test_formany  @test_exists   In each case, the basic format is  @[test] [set of values to test] [property to test]  The  property  is any expression that evaluates to a boolean, making reference to some dummy variable specified in the set of values to test.  The macros differ in how they specify and choose values to test:   Use  @test_forall  when you can specify the exact  finite set  of values to  test.  For example,  -3:3  specifies the exact set of 7 Int64 values, {-3,-2,-1,0,1,2,3}, on which you wish to test the property. Because the user specifies the test universe completely, and that universe is finite, every value is tested and @test_forall returns only true positives and true negatives.  Use  @test_formany  when you wish to specify a (possibly infinite) set of values  to test by restricted comprehension from some universe.  For example,  -3   x::Float64   3  specifies that some number of  Float64 s  x , satisfying the condition  -3   x   3 , will be tested for the property. Note that  @test_formany  is meant to capture the idea of the universal  quantifier, but is not universal on infinite sets,  since the package will only run a finite number of tests. That is,  @test_formany  may return a false positive, as it cannot be comprehensive. It will not, however, return a false negative.  Use  @test_exists  like  @test_formany , but when you wish the test to pass when  at least one value satisfies the property, rather than when all tested values satisfy the property. Like  @test_formany ,  @test_exists   simulates  the existential quantifier, but is not strictly speaking complete.  That is,  @test_exists  may return a false negative, in the case that a value exists but was not lucky enough to be tested. It will not, however, return a false positive.", 
            "title": "Quickstart Guide"
        }, 
        {
            "location": "/#the-macros-in-more-detail", 
            "text": "@test_forall  takes an expression specifying one or more dummy variables, discrete sets of values for those variables, and an expression, and tests the expression substituting every combination of the variables  (the Cartesian product of their possible value sets).  (Since Julia 0.5,  @test_forall x in [Collection], P(x)  is quite similar to   @test for x in [Collection] P(x) end , and we may deprecate / remove it for that reason.)  The property may be a conditional expression such as  P(x) --  Q(x) , in which case truth may be vacuous when  P(x)  is false  \\forall x  tested.  @test_formany  functions like  @test_forall , but allows quantifying over infinite sets such as  [a,b] \\subset \\mathbb R , etc. by sampling these sets uniformly at random. It provides additional modifiers to control how many tests it runs, which are especially helpful for ensuring that conditional-expression tests are not only passed vacuously.  @test_exists X  is essentially shorthand for  ! (@test_formany !X) .", 
            "title": "The Macros in More Detail"
        }, 
        {
            "location": "/#exhaustion", 
            "text": "Note that  @test_formany  and  @test_exists  are not strictly speaking exhaustive or true universal/existential quantifiers.  @test_formany x Expr(x)  may pass even when  \\exists x  s.t.  Expr(x)  is false, and  @test_exists x Expr(x)  may fail even under the same circumstances. However,  @test_forall  is exhaustive.  Tests that do not exhaust their universe take additional keyword arguments   ntests  and  maxtests  to control how many tests to run.", 
            "title": "Exhaustion"
        }, 
        {
            "location": "/#examples", 
            "text": "Basic usage:  @test_forall  x in 1:5,  x^2   30\n@test_formany 1   x   5, x^2   30\n@test_exists  1   x   5, x^2   30  Control how many tests in  @test_formany :  @test_formany ntests = 10_000  1   x   5, x^2   30  Test a conditional property, passing only if 100 of the tests are not vacuous:  @test_formany ntests = 100  0   x   Inf, 0   y   Inf,  x   y --  log(x) log(y)  Test a conditional property, passing only if 100 of the tests are not vacuous, but only allow 100 tests:  @test_formany ntests = 100 maxtests = 100  0   x   10,  0   y   10,  x   y --  x^2   y^2  Test a conditional property, passing only if 100 of the test are not vacuous, but allow 100,000 tests:  @test_formany ntests = 100 maxtests = 100_000 0   x   10,  0   y   10,  x   y --  x^2   y^2  Note that while the former ( maxtests=100 ) usually fails, the latter ( maxtests=100_000 ) passes.  This is because  @test_formany  generates 100 random pairs of  (x,y) , but not all of them are likely to satisfy  x   y . Therefore when  maxtests=100 , it will not generate enough pairs to test the consequent of the conditional expression.  See  ?@test_forall , etc. and  examples/examples.jl  for more detailed information.", 
            "title": "Examples"
        }, 
        {
            "location": "/#logging", 
            "text": "Test logging is available in  @test_formany  to see which values were actually tested by using the keyword  logto  and supplying an output path:  @test_formany logto =  tests.csv  1 x 5, x^2   30", 
            "title": "Logging"
        }, 
        {
            "location": "/#output", 
            "text": "Test macros output results of type  Base.Test.Pass ,  Base.Test.Fail ,  or  Base.Test.Error  in order to function seamlessly with  Base.Test.@testset .  @testset  Multiple tests  begin \n    @test_forall x in 1:5, x^2   30\n    @test_forall x in 1:6, x^2   30\nend", 
            "title": "Output"
        }, 
        {
            "location": "/#see-also", 
            "text": "Also of note are these more comprehensive (and we feel complicated) packages.  Our goal is to provide a lightweight, ready-to-use out-of-the-box alternative:   BaseTestAuto  DataGenerators", 
            "title": "See Also"
        }, 
        {
            "location": "/#license", 
            "text": "The Checkers.jl package is licensed under the MIT \"Expat\" License:  Copyright (c) 2017: Efim Abrikosov   Philip Kalikman.  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/#credits", 
            "text": "This package was co-designed and co-written by   Efim Abrikosov  and   Philip Kalikman  while each was a graduate student at Yale University.   Efim wrote the majority of the code, which is based on but does not directly use  the work of Patrick O'Leary  Philip designed the majority of the functionality and syntax, building on  the work (in Haskell) of Koen Classen and John Hughes", 
            "title": "Credits"
        }, 
        {
            "location": "/#index", 
            "text": "Checkers.@test_exists  Checkers.@test_forall  Checkers.@test_formany", 
            "title": "Index"
        }, 
        {
            "location": "/macros/test-forall/", 
            "text": "#\n\n\nCheckers.@test_forall\n \n \nMacro\n.\n\n\n@test_forall argument_data, prop\n\n\n\n\n\nChecks \nprop\n on each tuples of values specified in \nargument_data\n.  Returns \nPass\n if \nprop\n holds for all values tested, \nFail\n if \nprop\n does not hold for some tested value,  and \nError\n if a part of code could not be evaluated.\n\n\nArguments\n\n\n\n\nargument_data\n: a sequence of at least one comma-separated expression(s), specifying the sets of values for individual variables.   Expressions must have the form \nx in iter\n,  where \nx\n is any symbol that will be treated as a dummy variable,  and \niter\n is any iterable expression,  i.e. one valid in constructing a for loop: \n\"for x in iter\"\n. In particular, \niter\n can be \na:b\n,  where \na\n \n \nb\n are integer-valued expressions; an array; or a set.\n\n\nprop\n is boolean-valued expression of the proposition to be checked for arguments in specified ranges,  with reference to the dummy variables named in \nargument_data\n.\n\n\n\n\nDetails\n\n\n@test_forall\n constructs a nested sequence of for-loops, and checks that \nprop\n evaluates to \ntrue\n  for all combinations of values of variables specified by the loops.  In set-theoretic terms, \n@test_forall\n tests  \nprop\n on the Cartesian product of the sets of variables specified in \nargument_data\n.\n\n\nLoops are generated from \nargument_data\n inductively,  starting with the outermost loop as the leftmost expression, to the innermost loop as the rightmost.  Variable ranges may depend on the values of previously referenced variables (see third example).\n\n\nExamples\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n-\n1\n:\n1\n,\n \nx\n*\n(\nx\n-\n1\n)\n*\n(\nx\n+\n1\n)\n \n==\n \n0\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n-\n1\n:\n1\n,\nx\n \n*\n \n(\nx\n \n-\n \n1\n)\n \n*\n \n(\nx\n \n+\n \n1\n)\n \n==\n \n0\n)\n\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n-\n1\n:\n1\n,\n \nx\n*\n(\nx\n-\n2\n)\n*\n(\nx\n+\n1\n)\n \n==\n \n0\n\n\nTest\n \nFailed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n-\n1\n:\n1\n,\nx\n \n*\n \n(\nx\n \n-\n \n2\n)\n \n*\n \n(\nx\n \n+\n \n1\n)\n \n==\n \n0\n)\n\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n[\n0\n,\n1\n,\n2\n],\n \ny\n \nin\n \nx\n:\n4\n,\n \ny\n+\n4\n \n \n2\n*\nx\n \n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n[\n0\n,\n1\n,\n2\n],\ny\n \nin\n \nx\n:\n4\n,(\ny\n \n+\n \n4\n \n \n2\nx\n)\n \n==\n \ntrue\n)\n\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n(\n1\n-\n1\n,\n \n0\n+\n1\n,\n \nsqrt\n(\n4\n)),\n \ny\n \nin\n \nx\n:\n4\n,\n \ny\n+\n4\n \n \n2\n*\nx\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n(\n1\n \n-\n \n1\n,\n0\n \n+\n \n1\n,\nsqrt\n(\n4\n)),\ny\n \nin\n \nx\n:\n4\n,(\ny\n \n+\n \n4\n \n \n2\nx\n)\n \n==\n \ntrue\n)\n\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n[\na\n,\nb\n],\n \ny\n \nin\n \n[\nz\n,\nw\n],\n \nx\n*\ny\n \nin\n \nSet\n([\naz\n,\naw\n,\nbz\n,\nbw\n])\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n[\na\n,\nb\n],\ny\n \nin\n \n[\nz\n,\nw\n],\nx\n \n*\n \ny\n \nin\n \nSet\n([\naz\n,\naw\n,\nbz\n,\nbw\n]))\n\n\n\n# Bad design: throws UndefVarError: x not defined\n\n\n# The outer loop for `y` refers to `x`, which comes later in `argument_data`.\n\n\njulia\n \n@test_forall\n \ny\n \nin\n \nx\n:\n4\n,\n \nx\n \nin\n \n0\n:\n2\n,\n \ny\n+\n4\n \n \n2\n*\nx\n\n\nError\n \nDuring\n \nTest\n\n  \nTest\n \nthrew\n \nan\n \nexception\n \nof\n \ntype\n \nUndefVarError\n\n  \nExpression\n:\n \n(\ny\n \nin\n \nx\n:\n4\n,\nx\n \nin\n \n0\n:\n2\n,(\ny\n \n+\n \n4\n \n \n2\nx\n)\n \n==\n \ntrue\n)\n\n  \nUndefVarError\n:\n \nx\n \nnot\n \ndefined\n\n\n\n\n\n\nsource", 
            "title": "Test-forall"
        }, 
        {
            "location": "/macros/test-formany/", 
            "text": "#\n\n\nCheckers.@test_formany\n \n \nMacro\n.\n\n\n@test_formany [ntests = 100] [maxtests = 1000] [logto = \n] argument_data, prop\n\n\n\n\n\nChecks \nprop\n on randomly generated samples values specified in \nargument_data\n.  Returns \nPass\n if \nprop\n holds for all values in the sample,  \nFail\n if \nprop\n does not hold for some sampled value,  and \nError\n if a part of the code could not be evaluated or if insufficient non-vacuous tests are generated.\n\n\nArguments\n\n\n\n\n\n\nargument_data\n: a sequence of comma-separated expressions,  where each expression specifies a dummy variable, a universe from which to sample it, and a restricted comprehension of that universe. In particular, expressions must have one of the following forms:\n\n\n\n\na\nx::T\nb\n or \na\nx::T\nb\n, where \nx\n is any symbol, treated as a dummy variable; \nT\n is a type; \na\n \n \nb\n are arbitrary expressions to constrain the range of values for \nx\n (provided that \na\nx::T\nb\n is meaningful given \nT\n and the types of \na\n and \nb\n);\n\n\na\nx::T\nb\n, \na\nx::T\nb\n, \na\nx::T\nb\n or \na\nx::T\nb\n, as above, but where using \n will instruct \n@test_formany\n to generate test cases \naway\n from that boundary, i.e. closer  to the other boundary;\n\n\na\nx\nb\n etc., where the type \nT\n is omitted, and therefore defaults to \nFloat64\n\n\n\n\n\n\n\n\nprop\n: the property to be tested. Two types of properties are allowed:\n\n\n\n\nany boolean-valued expression, referencing the dummy variables defined in \nargument_data\n, or\n\n\na property of the form \nantecedent --\n consequent\n,  where \nantecedent\n and \nconsequent\n are themselves boolean-valued expressions that may reference dummy variables defined in \nargument_data\n. This form is useful for  expressing \"if-then\" relationships without thinking through  how to generate test cases that satisfy the antecedent, as \n@test_formany\n will do this for you; see below for more detail.\n\n\n\n\n\n\n\n\nOptional keyword arguments include the following:\n\n\n\n\nntests = 100\n: the number of tests that \ntest_formany\n will perform\n\n\n\n\nbefore returning \nPass\n.\n\n\n\n\nmaxtests = 1000\n: the maximal number of times to attempt to generate\n\n\n\n\ntest cases that satisfy \nantecedent\n, when the \nantecedent --\n consequent\n form is used.\n\n\n\n\nlogto = \"path_to_file\"\n: the path to a file to which\n\n\n\n\na log of the actual test cases used will be recorded. Since \n@test_formany\n is pseudo-random and might pass a test that you expect to fail (or vice versa), this can be useful for debugging to see which actual test cases were tested.\n\n\nDetails\n\n\n@test_formany\n generates a sample of test cases based on \nargument_data\n,  and tests \nprop\n on these values, returning \nPass\n only if every test passes.\n\n\nBasic Use\n\n\nWhen \nprop\n is just a boolean-valued expression, \n@test_formany\n simply checks whether \nprop\n holds for the values generated according to \nargument_data\n.\n\n\nAdvanced Use: Conditional Properties and Vacuity Avoidance\n\n\nWhen using \nntests = [some integer]\n, with a \nprop\n of the form \nantecedent --\n consequent\n, \n@test_formany\n will attempt to test \nntests\n cases where the conditional is \nnot\n vacuous, i.e. \nntests\n cases where \nantecedent\n evaluates to true.  However, to prevent the test from looping infinitely, \n@test_formany\n uses \nmaxtests = [some integer]\n  to limit the number of total attempts it will make.\n\n\nConsider the following example: you might wish to test this statement:\n\n\n\u2200 0 \n x \n 1, x^2 \n 0.0001 --\n x \n 0.01\n\n\n\n\n\nIf you simply tested this statement with 100 randomly sampled values between 0 and 1, you would be unlikely actually ever  to evaluate the consequent of the conditional, because most of the time x^2 \n 0.0001 would not be true. So, you could use \n\n\n@test_formany ntests=100 0 \n x::Float64 \n 1, x^2 \n 0.0001 --\n x \n 0.01\n\n\n\n\n\nto guarantee 100 tests where \nx^2 \n 0.0001\n was true.\n\n\nHowever, by the same reasoning, you might actually be testing an expression for which the antecedent is itself virtually always false. Then you don't want the tests to continue forever\u2013-you want to specify an upper bound on how many tests \n@test_formany\n should run before it gives up. For example, using \nmaxtests\n in this case prevents \n@test_formany\n from looping infinitely  looking for a value that satisfies an impossible antecedent:\n\n\n@test_formany ntests=100 maxtests=10_000 0 \n x::Float64 \n 1, (x \n 1 \n x \n 2) --\n x \n 0.01\n\n\n\n\n\nIn this case, if the number of attempts to satisfy the antecedent exceeds \nmaxtests\n before \nntests\n tests \ndo\n satisfy the antecedent, then \n@test_formany\n will return \nBase.Test.Error\n.\n\n\nKeyword Argument Defaults\n\n\n\n\nIf no keywords are specified, \n@test_formany\n assumes \nntests = 100, maxtests = 1000\n.\n\n\nIf only \nntests\n is specified, \n@test_formany\n assumes \nmaxtests = 10*ntests\n.\n\n\nBy default, \n@test_formany\n does \nnot\n log output\n\n\n\n\nKeyword arguments are order-invariant.\n\n\nExhaustion\n\n\n@test_formany\n tests a random sample of values specified by \nargument_data\n, which in typical use will imply that it tests a random sample of values drawn from a mathematically infinite set.  Consequently, \n@test_formany\n is not exhaustive, and can therefore generate false positives, i.e. cases that generate \nPass\n even when a counter-example exists.\n\n\nA similar and more complicated concern applies when using conditional properties. Here, the vacuity-avoidance arguments \nntests\n and \nmaxtests\n may result in false positives and false negatives: a conditional that is true, but with an unlikely-to-satisfy antecedent,  mail fail to generate enough test cases to test the entire conditional, and therefore return \nError\n even when the  property is true for the entire universe. On the other hand, a counter-example may still exists even when \n@test_formany\n returns \nPass\n on a conditional property after testing many non-vacuous antecedents.\n\n\nExamples\n\n\njulia\n \n@test_formany\n \n100\n \n \nx\n::\nFloat64\n \n \n10\n,\n \nx\n+\n10\n \n \ny\n::\nFloat64\n \n \n1000\n,\n \ny\n-\n5\n \n \nz\n::\nFloat64\n \n \nInf\n,\n \nz\n \n \nx\n+\n5\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n100\n \n \nx\n::\nFloat64\n \n \n10\n,\nx\n \n+\n \n10\n \n \ny\n::\nFloat64\n \n \n1000\n,\ny\n \n-\n \n5\n \n \nz\n::\nFloat64\n \n \nInf\n,\nz\n \n \nx\n \n+\n \n5\n)),)\n\n\n\njulia\n \n@test_formany\n \nntests\n \n=\n \n1000\n \n10\n \n \nx\n::\nFloat64\n \n \n100\n,\n \nx\n+\n10\n \n \ny\n::\nFloat64\n \n \n1000\n,\n \ny\n-\n5\n \n \nz\n::\nFloat64\n \n \nInf\n,\n \nz\n \n \nx\n+\n6\n\n\nString\n[\nx = 25.18875813550991\n,\ny = 35.192306691353075\n,\nz = 31.183953098939906\n]\n\n\nTest\n \nFailed\n\n  \nExpression\n:\n \n(\n:\n(\nntests\n \n=\n \n1000\n),\n:\n((\n100\n \n \nx\n::\nFloat64\n \n \n10\n,\nx\n \n+\n \n10\n \n \ny\n::\nFloat64\n \n \n1000\n,\ny\n \n-\n \n5\n \n \nz\n::\nFloat64\n \n \nInf\n,\nz\n \n \nx\n \n+\n \n6\n)))\n\n\n\n## Failing to find enough non-vacuous test cases:\n\n\njulia\n \n@test_formany\n \n-\n1000\n \n \nx\n::\nFloat64\n \n \n1000\n,\n \nx\n \n \n999\n \n--\n \nx\n+\n1\n \n \n1000\n\n\nError\n \nDuring\n \nTest\n\n  \nTest\n \nthrew\n \nan\n \nexception\n \nof\n \ntype\n \nErrorException\n\n  \nExpression\n:\n \n(\n:\n((\n-\n1000\n \n \nx\n::\nFloat64\n \n \n1000\n,\n$\n(\nExpr\n(\n:--\n,\n \n:\n(\nx\n \n \n999\n),\n \n:\n(\nx\n \n+\n \n1\n \n \n1000\n))))),)\n\n  \nFound\n \nonly\n \n1\n/\n100\n \nvalues\n \nsatisfying\n \ngiven\n \nantecedent\n.\n\n\n\n## Test that `log` is an increasing function\n\n\njulia\n  \n@test_formany\n \nntests\n=\n1000\n \nInf\n \n \nx\n::\nFloat64\n \n \n0\n,\n \nInf\n \n \ny\n::\nFloat64\n \n \n0\n,\n \nx\n \n \ny\n \n--\n \nlog\n(\nx\n)\n \n \nlog\n(\ny\n)\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\nInf\n \n \nx\n::\nFloat64\n \n \n0\n,\nInf\n \n \ny\n::\nFloat64\n \n \n0\n,\n$\n(\nExpr\n(\n:--\n,\n \n:\n(\nx\n \n \ny\n),\n \n:\n(\nlog\n(\nx\n)\n \n \nlog\n(\ny\n)))))),\n:\n(\nntests\n \n=\n \n1000\n))\n\n\n\n## Test that f(x) = x^3 is convex on (-100,100) \n\n\n## Fails, because f(x) = x^3 is not convex on that interval!\n\n\njulia\n \n@test_formany\n \n0\n \n \na\n \n \n1\n,\n-\n100\n \n \nx\n \n \n100\n,\n-\n100\n \n \ny\n \n \n100\n,(\na\n*\nx\n \n+\n \n(\n1\n-\na\n)\n*\ny\n)\n^\n3\n \n \na\n*\nx\n^\n3\n \n+\n \n(\n1\n-\na\n)\n*\ny\n^\n3\n\n\nString\n[\na = 0.39535367198058546\n,\nx = -13.538004569422625\n,\ny = 0.8504731053549079\n]\n\n\nTest\n \nFailed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \na\n \n \n1\n,\n-\n100\n \n \nx\n \n \n100\n,\n-\n100\n \n \ny\n \n \n100\n,(\na\n \n*\n \nx\n \n+\n \n(\n1\n \n-\n \na\n)\n \n*\n \ny\n)\n \n^\n \n3\n \n \na\n \n*\n \nx\n \n^\n \n3\n \n+\n \n(\n1\n \n-\n \na\n)\n \n*\n \ny\n \n^\n \n3\n)),)\n\n\n\n## Test that f(x) = x^3 is convex on (0,100)\n\n\njulia\n \n@test_formany\n \n0\na\n1\n,\n0\nx\n100\n,\n0\ny\n100\n,\n \n(\na\n*\nx\n+\n(\n1\n-\na\n)\n*\ny\n)\n^\n3\n=\na\n*\nx\n^\n3\n+\n(\n1\n-\na\n)\n*\ny\n^\n3\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \na\n \n \n1\n,\n0\n \n \nx\n \n \n100\n,\n0\n \n \ny\n \n \n100\n,(\na\n \n*\n \nx\n \n+\n \n(\n1\n \n-\n \na\n)\n \n*\n \ny\n)\n \n^\n \n3\n \n=\n \na\n \n*\n \nx\n \n^\n \n3\n \n+\n \n(\n1\n \n-\n \na\n)\n \n*\n \ny\n \n^\n \n3\n)),)\n\n\n\n## Test that Cobb-Douglas Utility is concave:\n\n\n## First, define a helper function for concavity testing\n\n\njulia\n \nfunction\n \nrespects_concavity\n(\nf\n,\nt\n,\nx1\n,\nx2\n)\n\n                  \nf\n(\nt\n*\nx1\n+\n(\n1\n-\nt\n)\n*\nx2\n)\n \n \nt\n \n*\n \nf\n(\nx1\n)\n \n+\n \n(\n1\n-\nt\n)\n \n*\n \nf\n(\nx2\n)\n\n              \nend\n\n\n## Same for weak concavity\n\n\njulia\n \nfunction\n \nrespects_weak_concavity\n(\nf\n,\nt\n,\nx1\n,\nx2\n)\n\n                  \nf\n(\nt\n*\nx1\n+\n(\n1\n-\nt\n)\n*\nx2\n)\n \n=\n \nt\n \n*\n \nf\n(\nx1\n)\n \n+\n \n(\n1\n-\nt\n)\n \n*\n \nf\n(\nx2\n)\n\n              \nend\n\n\n## And one for Cobb-Douglas\n\n\njulia\n \nfunction\n \ncobb_douglas\n(\na\n,\nx\n)\n\n                  \nprod\n(\nx\n.^\na\n)\n\n              \nend\n\n\n\n## The test below passes the @test_formany, \n\n\n## since the probability of discovering a counter-example is zero.\n\n\njulia\n \n@test_formany\n \n0\nt\n1\n,\n \n0\na\n1\n,\n \n1\nx1\n10\n,\n \n1\nx2\n10\n,\n \n1\ny1\n10\n,\n \n1\ny2\n10\n,\n \nrespects_concavity\n(\nx\n \n-\n \ncobb_douglas\n(\n \n[\na\n,\n1\n-\na\n],\n \nx\n),\n \nt\n,\n \n[\nx1\n,\ny1\n],\n \n[\nx2\n,\ny2\n])\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nt\n \n \n1\n,\n0\n \n \na\n \n \n1\n,\n1\n \n \nx1\n \n \n10\n,\n1\n \n \nx2\n \n \n10\n,\n1\n \n \ny1\n \n \n10\n,\n1\n \n \ny2\n \n \n10\n,\nrespects_concavity\n((\nx\n-\nbegin\n  \n# REPL[5], line 1:\n\n                    \ncobb_douglas\n([\na\n,\n1\n \n-\n \na\n],\nx\n)\n\n                \nend\n),\nt\n,[\nx1\n,\ny1\n],[\nx2\n,\ny2\n]))),)\n\n\n\njulia\n \n@test_formany\n \n0\n \n \nt\n \n \n1\n,\n \n0\n \n \na\n \n \n1\n,\n \n1\n \n \nx1\n \n \n10\n,\n \n1\n \n \nx2\n \n \n10\n,\n \n1\n \n \ny1\n \n \n10\n,\n \n1\n \n \ny2\n \n \n10\n,\nrespects_weak_concavity\n(\nx\n \n-\n \ncobb_douglas\n(\n \n[\na\n,\n1\n-\na\n],\n \nx\n),\n \nt\n,\n \n[\nx1\n,\ny1\n],\n \n[\nx2\n,\ny2\n])\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nt\n \n \n1\n,\n0\n \n \na\n \n \n1\n,\n1\n \n \nx1\n \n \n10\n,\n1\n \n \nx2\n \n \n10\n,\n1\n \n \ny1\n \n \n10\n,\n1\n \n \ny2\n \n \n10\n,\nrespects_weak_concavity\n((\nx\n-\nbegin\n  \n# REPL[6], line 1:\n\n                    \ncobb_douglas\n([\na\n,\n1\n \n-\n \na\n],\nx\n)\n\n                \nend\n),\nt\n,[\nx1\n,\ny1\n],[\nx2\n,\ny2\n]))),)\n\n\n\n## Handling Errors\n\n\njulia\n \n@test_formany\n \n-\n1\n \n \nx\n \n \n1\n,\n \nabs\n(\n \nlog\n(\nx\n)\n \n)\n \n \n0\n\n\nError\n \nDuring\n \nTest\n\n  \nTest\n \nthrew\n \nan\n \nexception\n \nof\n \ntype\n \nDomainError\n\n  \nExpression\n:\n \n(\n:\n((\n-\n1\n \n \nx\n \n \n1\n,\nabs\n(\nlog\n(\nx\n))\n \n \n0\n)),)\n\n  \nDomainError\n\n\n\n\n\n\nsource", 
            "title": "Test-formany"
        }, 
        {
            "location": "/macros/test-exists/", 
            "text": "#\n\n\nCheckers.@test_exists\n \n \nMacro\n.\n\n\n@test_exists [ntests = 100] [maxtests = 1000] [logto = \n] argument_data, prop\n\n\n\n\n\nChecks \nprop\n on randomly generated samples values specified in \nargument_data\n.  Returns \nPass\n if \nprop\n holds for at least one value in the sample,  \nFail\n if \nprop\n fails to hold for all sampled values,  and \nError\n if a part of the code could not be evaluated or if insufficient non-vacuous tests are generated.\n\n\nDescription\n\n\n@test_exists\n is to \n@test_formany\n as the existential quantifier is to the universal quantifier. That is, \n\n\n( @test_exists x \u2208 X, P(x)  ) == !( @test_formany x \u2208 X, !P(x) )\n\n\n\n\n\nConsequently, the same concerns with vacuity avoidance apply. Additionally, analogous concerns with false positivity  apply: where \n@test_formany\n may falsely validate a property by not exhausting its implicit test universe, \n@test_exists\n may falsely \nin\nvalidate a property by not exhausting its implicit search universe.\n\n\nExamples\n\n\njulia\n \n@test_exists\n \nntests\n \n=\n \n1000\n \n-\n10\n \n \nx\n \n \n10\n,\n \nx\n^\n2\n \n \n99\n\n\nString\n[\nx = -9.966560160994264\n]\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n(\nntests\n \n=\n \n1000\n),\n:\n((\n-\n10\n \n \nx\n \n \n10\n,\nx\n \n^\n \n2\n \n \n99\n)))\n\n\n\n## Here, the values of x, y, and z are generated independently, \n\n\n## so a conditional statement with an antecedent that checks for\n\n\n## order is necessary: \n\n\njulia\n \n@test_exists\n \nntests\n \n=\n \n1000\n \n0\n \n \nx\n \n \n2\n*\npi\n,\n \n0\n \n \ny\n \n \n2\n*\npi\n,\n \n0\n \n \nz\n \n \n2\n*\npi\n,\n \nx\n \n \ny\n \n \nz\n \n--\n \nsin\n(\nx\n)\n \n \nsin\n(\ny\n)\n \n \nsin\n(\nz\n)\n \n\nString\n[\nx = 0.3082312611033726\n,\ny = 0.49557010329840206\n,\nz = 2.5966119472766076\n]\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nx\n \n \n2\npi\n,\n0\n \n \ny\n \n \n2\npi\n,\n0\n \n \nz\n \n \n2\npi\n,\n$\n(\nExpr\n(\n:--\n,\n \n:\n(\nx\n \n \ny\n \n \nz\n),\n \n:\n(\nsin\n(\nx\n)\n \n \nsin\n(\ny\n)\n \n \nsin\n(\nz\n)))))),\n:\n(\nntests\n \n=\n \n1000\n))\n\n\n\n## By contrast, here, x, y, and z are generated with sequential \n\n\n## reference to the previously generated value(s), \n\n\n## so they satisfy x\ny\nz automatically.\n\n\n## No conditional is needed.\n\n\njulia\n \n@test_exists\n \n0\nx\n2\n*\npi\n,\n \nx\ny\n2\n*\npi\n,\n \ny\nz\n2\n*\npi\n,\n \nsin\n(\nx\n)\nsin\n(\ny\n)\nsin\n(\nz\n)\n\n\nString\n[\nx = 5.787034350107664\n,\ny = 6.23560263220101\n,\nz = 6.26802436856299\n]\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nx\n \n \n2\npi\n,\nx\n \n \ny\n \n \n2\npi\n,\ny\n \n \nz\n \n \n2\npi\n,\nsin\n(\nx\n)\n \n \nsin\n(\ny\n)\n \n \nsin\n(\nz\n))),)\n\n\n\n## This returns Error, because the antecedent is too restrictive\n\n\n## to generate 100 non-vacuous tests:\n\n\n@test_exists\n \nntests\n \n=\n \n100\n \n0\n \n \nx\n \n \n1000\n,\n \nx\n \n \n990\n \n--\n \nx\n \n \n999.9\n \n\nError\n \nDuring\n \nTest\n\n  \nTest\n \nthrew\n \nan\n \nexception\n \nof\n \ntype\n \nErrorException\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nx\n \n \n1000\n,\n$\n(\nExpr\n(\n:--\n,\n \n:\n(\nx\n \n \n990\n),\n \n:\n(\nx\n \n \n999.9\n))))),\n:\n(\nntests\n \n=\n \n100\n))\n\n  \nFound\n \nonly\n \n14\n/\n100\n \nvalues\n \nsatisfying\n \ngiven\n \ncondition\n.\n\n\n\n\n\n\nsource", 
            "title": "Test-exists"
        }
    ]
}