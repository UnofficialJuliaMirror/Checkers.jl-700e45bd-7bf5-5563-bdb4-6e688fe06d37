{
    "docs": [
        {
            "location": "/", 
            "text": "Checkers \ud83c\udfc1 \ud83c\udfc1 Documentation\n\n\n\n\nContents\n\n\n\n\nCheckers \ud83c\udfc1 \ud83c\udfc1 Documentation\n\n\nContents\n\n\nIntroduction\n\n\nQuickstart Guide\n\n\nThe Macros in More Detail\n\n\nSee Also\n\n\nLicense\n\n\nCredits\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nAutomated testing macros inspired by a \nJulia implementation\n of Koen Claessen and John Hughes' \nQuickCheck\n property-based randomized tester.\n\n\nCheckers lets you write quick property-based tests:\n\n\njulia\n using Checkers\njulia\n f(x) = x^2\njulia\n @test_formany -10\nx\n10, f(x) \n= 0\nTest Passed\n  Expression: (:((-10 \n x \n 10, f(x) \n= 0)), :(mode = test_formany))\n\njulia\n @test_forall x in -10:10, f(x) \n=0\nTest Passed\n  Expression: (x in -10:10, f(x) \n= 0)\n    @test_forall x in 0:10, f(x) \n= 0\n\njulia\n @test_forall x in -10:10, f(x) \n 0 #Should fail b/c f(0) = 0\nTest Failed\n  Expression: (x in -10:10, f(x) \n 0)\nERROR: There was an error during testing\n\n\n\n\n\n\n\nQuickstart Guide\n\n\nThis package provides three macros for test generation:\n\n\n\n\n@test_forall\n\n\n@test_formany\n\n\n@test_exists\n\n\n\n\nIn each case, the basic format is\n\n\n@[test] [set of values to test] [property to test]\n\n\n\n\n\nThe \nproperty\n is any expression that evaluates to a boolean, making reference to some dummy variable specified in the set of values to test.\n\n\nThe macros differ in how they specify and choose values to test:\n\n\n\n\nUse \n@test_forall\n when you can specify the exact \nfinite set\n of values to  test.  For example, \n-3:3\n specifies the exact set of 7 Int64 values, {-3,-2,-1,0,1,2,3}, on which you wish to test the property. Because the user specifies the test universe completely, and that universe is finite, every value is tested and @test_forall returns only true positives and true negatives.\n\n\nUse \n@test_formany\n when you wish to specify a (possibly infinite) set of values  to test by restricted comprehension from some universe.  For example, \n-3 \n x::Float64 \n 3\n specifies that some number of \nFloat64\ns \nx\n, satisfying the condition \n-3 \n x \n 3\n, will be tested for the property. Note that \n@test_formany\n is meant to capture the idea of the universal  quantifier, but is not universal on infinite sets,  since the package will only run a finite number of tests. That is, \n@test_formany\n may return a false positive, as it cannot be comprehensive. It will not, however, return a false negative.\n\n\nUse \n@test_exists\n like \n@test_formany\n, but when you wish the test to pass when  at least one value satisfies the property, rather than when all tested values satisfy the property. Like \n@test_formany\n, \n@test_exists\n \nsimulates\n the existential quantifier, but is not strictly speaking complete.  That is, \n@test_exists\n may return a false negative, in the case that a value exists but was not lucky enough to be tested. It will not, however, return a false positive.\n\n\n\n\n\n\nThe Macros in More Detail\n\n\n@test_forall\n takes an expression specifying one or more dummy variables, discrete sets of values for those variables, and an expression, and tests the expression substituting every combination of the variables  (the Cartesian product of their possible value sets).  (Since Julia 0.5, \n@test_forall x in [Collection], P(x)\n is quite similar to  \n@test for x in [Collection] P(x) end\n, and we may deprecate / remove it for that reason.)\n\n\nThe property may be a conditional expression such as \nP(x) --\n Q(x)\n, in which case truth may be vacuous when \nP(x)\n is false \n\\forall x\n tested.\n\n\n@test_formany\n functions like \n@test_forall\n, but allows quantifying over infinite sets such as \n[a,b] \\subset \\mathbb R\n, etc. by sampling these sets uniformly at random. It provides additional modifiers to control how many tests it runs, which are especially helpful for ensuring that conditional-expression tests are not only passed vacuously.\n\n\n@test_exists X\n is essentially shorthand for \n! (@test_formany !X)\n.\n\n\n\n\nExhaustion\n\n\nNote that \n@test_formany\n and \n@test_exists\n are not strictly speaking exhaustive or true universal/existential quantifiers. \n@test_formany x Expr(x)\n may pass even when \n\\exists x\n s.t. \nExpr(x)\n is false, and \n@test_exists x Expr(x)\n may fail even under the same circumstances. However, \n@test_forall\n is exhaustive.\n\n\nTests that do not exhaust their universe take additional keyword arguments  \nntests\n and \nmaxtests\n to control how many tests to run.\n\n\n\n\nExamples\n\n\nBasic usage:\n\n\n@test_forall  x in 1:5,  x^2 \n 30\n@test_formany 1 \n x \n 5, x^2 \n 30\n@test_exists  1 \n x \n 5, x^2 \n 30\n\n\n\n\n\nControl how many tests in \n@test_formany\n:\n\n\n@test_formany ntests = 10_000  1 \n x \n 5, x^2 \n 30\n\n\n\n\n\nTest a conditional property, passing only if 100 of the tests are not vacuous:\n\n\n@test_formany ntests = 100  0 \n x \n Inf, 0 \n y \n Inf,  x \n y --\n log(x)\nlog(y)\n\n\n\n\n\nTest a conditional property, passing only if 100 of the tests are not vacuous, but only allow 100 tests:\n\n\n@test_formany ntests = 100 maxtests = 100  0 \n x \n 10,  0 \n y \n 10,  x \n y --\n x^2 \n y^2\n\n\n\n\n\nTest a conditional property, passing only if 100 of the test are not vacuous, but allow 100,000 tests:\n\n\n@test_formany ntests = 100 maxtests = 100_000 0 \n x \n 10,  0 \n y \n 10,  x \n y --\n x^2 \n y^2\n\n\n\n\n\nNote that while the former (\nmaxtests=100\n) usually fails, the latter (\nmaxtests=100_000\n) passes.  This is because \n@test_formany\n generates 100 random pairs of \n(x,y)\n, but not all of them are likely to satisfy \nx \n y\n. Therefore when \nmaxtests=100\n, it will not generate enough pairs to test the consequent of the conditional expression.\n\n\nSee \n?@test_forall\n, etc. and \nexamples/examples.jl\n for more detailed information. \n\n\n\n\nLogging\n\n\nTest logging is available in \n@test_formany\n to see which values were actually tested by using the keyword \nlogto\n and supplying an output path:\n\n\n@test_formany logto = \ntests.csv\n 1\nx\n5, x^2 \n 30\n\n\n\n\n\n\n\nOutput\n\n\nTest macros output results of type \nBase.Test.Pass\n, \nBase.Test.Fail\n,  or \nBase.Test.Error\n in order to function seamlessly with \nBase.Test.@testset\n.\n\n\n@testset \nMultiple tests\n begin \n    @test_forall x in 1:5, x^2 \n 30\n    @test_forall x in 1:6, x^2 \n 30\nend\n\n\n\n\n\n\n\nSee Also\n\n\nAlso of note are these more comprehensive (and we feel complicated) packages.  Our goal is to provide a lightweight, ready-to-use out-of-the-box alternative:\n\n\n\n\nBaseTestAuto\n\n\nDataGenerators\n\n\n\n\n\n\nLicense\n\n\nThe Checkers.jl package is licensed under the MIT \"Expat\" License:\n\n\nCopyright (c) 2017: Efim Abrikosov \n Philip Kalikman.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nCredits\n\n\nThis package was co-designed and co-written by  \nEfim Abrikosov\n and \nPhilip Kalikman\n while each was a graduate student at Yale University.\n\n\n\n\nEfim wrote the majority of the code,\n\n\n\n\nwhich is based on but does not directly use \nthe work of Patrick O'Leary\n\n\n\n\nPhilip designed the majority of the functionality and syntax,\n\n\n\n\nbuilding on \nthe work (in Haskell) of Koen Classen and John Hughes", 
            "title": "Home"
        }, 
        {
            "location": "/#checkers-documentation", 
            "text": "", 
            "title": "Checkers \ud83c\udfc1 \ud83c\udfc1 Documentation"
        }, 
        {
            "location": "/#contents", 
            "text": "Checkers \ud83c\udfc1 \ud83c\udfc1 Documentation  Contents  Introduction  Quickstart Guide  The Macros in More Detail  See Also  License  Credits", 
            "title": "Contents"
        }, 
        {
            "location": "/#introduction", 
            "text": "Automated testing macros inspired by a  Julia implementation  of Koen Claessen and John Hughes'  QuickCheck  property-based randomized tester.  Checkers lets you write quick property-based tests:  julia  using Checkers\njulia  f(x) = x^2\njulia  @test_formany -10 x 10, f(x)  = 0\nTest Passed\n  Expression: (:((-10   x   10, f(x)  = 0)), :(mode = test_formany))\n\njulia  @test_forall x in -10:10, f(x)  =0\nTest Passed\n  Expression: (x in -10:10, f(x)  = 0)\n    @test_forall x in 0:10, f(x)  = 0\n\njulia  @test_forall x in -10:10, f(x)   0 #Should fail b/c f(0) = 0\nTest Failed\n  Expression: (x in -10:10, f(x)   0)\nERROR: There was an error during testing", 
            "title": "Introduction"
        }, 
        {
            "location": "/#quickstart-guide", 
            "text": "This package provides three macros for test generation:   @test_forall  @test_formany  @test_exists   In each case, the basic format is  @[test] [set of values to test] [property to test]  The  property  is any expression that evaluates to a boolean, making reference to some dummy variable specified in the set of values to test.  The macros differ in how they specify and choose values to test:   Use  @test_forall  when you can specify the exact  finite set  of values to  test.  For example,  -3:3  specifies the exact set of 7 Int64 values, {-3,-2,-1,0,1,2,3}, on which you wish to test the property. Because the user specifies the test universe completely, and that universe is finite, every value is tested and @test_forall returns only true positives and true negatives.  Use  @test_formany  when you wish to specify a (possibly infinite) set of values  to test by restricted comprehension from some universe.  For example,  -3   x::Float64   3  specifies that some number of  Float64 s  x , satisfying the condition  -3   x   3 , will be tested for the property. Note that  @test_formany  is meant to capture the idea of the universal  quantifier, but is not universal on infinite sets,  since the package will only run a finite number of tests. That is,  @test_formany  may return a false positive, as it cannot be comprehensive. It will not, however, return a false negative.  Use  @test_exists  like  @test_formany , but when you wish the test to pass when  at least one value satisfies the property, rather than when all tested values satisfy the property. Like  @test_formany ,  @test_exists   simulates  the existential quantifier, but is not strictly speaking complete.  That is,  @test_exists  may return a false negative, in the case that a value exists but was not lucky enough to be tested. It will not, however, return a false positive.", 
            "title": "Quickstart Guide"
        }, 
        {
            "location": "/#the-macros-in-more-detail", 
            "text": "@test_forall  takes an expression specifying one or more dummy variables, discrete sets of values for those variables, and an expression, and tests the expression substituting every combination of the variables  (the Cartesian product of their possible value sets).  (Since Julia 0.5,  @test_forall x in [Collection], P(x)  is quite similar to   @test for x in [Collection] P(x) end , and we may deprecate / remove it for that reason.)  The property may be a conditional expression such as  P(x) --  Q(x) , in which case truth may be vacuous when  P(x)  is false  \\forall x  tested.  @test_formany  functions like  @test_forall , but allows quantifying over infinite sets such as  [a,b] \\subset \\mathbb R , etc. by sampling these sets uniformly at random. It provides additional modifiers to control how many tests it runs, which are especially helpful for ensuring that conditional-expression tests are not only passed vacuously.  @test_exists X  is essentially shorthand for  ! (@test_formany !X) .", 
            "title": "The Macros in More Detail"
        }, 
        {
            "location": "/#exhaustion", 
            "text": "Note that  @test_formany  and  @test_exists  are not strictly speaking exhaustive or true universal/existential quantifiers.  @test_formany x Expr(x)  may pass even when  \\exists x  s.t.  Expr(x)  is false, and  @test_exists x Expr(x)  may fail even under the same circumstances. However,  @test_forall  is exhaustive.  Tests that do not exhaust their universe take additional keyword arguments   ntests  and  maxtests  to control how many tests to run.", 
            "title": "Exhaustion"
        }, 
        {
            "location": "/#examples", 
            "text": "Basic usage:  @test_forall  x in 1:5,  x^2   30\n@test_formany 1   x   5, x^2   30\n@test_exists  1   x   5, x^2   30  Control how many tests in  @test_formany :  @test_formany ntests = 10_000  1   x   5, x^2   30  Test a conditional property, passing only if 100 of the tests are not vacuous:  @test_formany ntests = 100  0   x   Inf, 0   y   Inf,  x   y --  log(x) log(y)  Test a conditional property, passing only if 100 of the tests are not vacuous, but only allow 100 tests:  @test_formany ntests = 100 maxtests = 100  0   x   10,  0   y   10,  x   y --  x^2   y^2  Test a conditional property, passing only if 100 of the test are not vacuous, but allow 100,000 tests:  @test_formany ntests = 100 maxtests = 100_000 0   x   10,  0   y   10,  x   y --  x^2   y^2  Note that while the former ( maxtests=100 ) usually fails, the latter ( maxtests=100_000 ) passes.  This is because  @test_formany  generates 100 random pairs of  (x,y) , but not all of them are likely to satisfy  x   y . Therefore when  maxtests=100 , it will not generate enough pairs to test the consequent of the conditional expression.  See  ?@test_forall , etc. and  examples/examples.jl  for more detailed information.", 
            "title": "Examples"
        }, 
        {
            "location": "/#logging", 
            "text": "Test logging is available in  @test_formany  to see which values were actually tested by using the keyword  logto  and supplying an output path:  @test_formany logto =  tests.csv  1 x 5, x^2   30", 
            "title": "Logging"
        }, 
        {
            "location": "/#output", 
            "text": "Test macros output results of type  Base.Test.Pass ,  Base.Test.Fail ,  or  Base.Test.Error  in order to function seamlessly with  Base.Test.@testset .  @testset  Multiple tests  begin \n    @test_forall x in 1:5, x^2   30\n    @test_forall x in 1:6, x^2   30\nend", 
            "title": "Output"
        }, 
        {
            "location": "/#see-also", 
            "text": "Also of note are these more comprehensive (and we feel complicated) packages.  Our goal is to provide a lightweight, ready-to-use out-of-the-box alternative:   BaseTestAuto  DataGenerators", 
            "title": "See Also"
        }, 
        {
            "location": "/#license", 
            "text": "The Checkers.jl package is licensed under the MIT \"Expat\" License:  Copyright (c) 2017: Efim Abrikosov   Philip Kalikman.  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/#credits", 
            "text": "This package was co-designed and co-written by   Efim Abrikosov  and  Philip Kalikman  while each was a graduate student at Yale University.   Efim wrote the majority of the code,   which is based on but does not directly use  the work of Patrick O'Leary   Philip designed the majority of the functionality and syntax,   building on  the work (in Haskell) of Koen Classen and John Hughes", 
            "title": "Credits"
        }, 
        {
            "location": "/macros/test-forall/", 
            "text": "#\n\n\nCheckers.@test_forall\n \n \nMacro\n.\n\n\n@test_forall argument_data, prop\n\n\n\n\n\nCheck statement of proposition over all tuples of values of variables, specified in \nargument_data\n. Generate Pass/Fail/Error output for Base.Test. \n\n\nArguments\n\n\n\n\nargument_data\n: comma separated expression with arbitrarily many statements, containing information about ranges of variables. Statements must have form \nx in iter\n, where \nx\n is symbol and \niter\n is any expression valid in \n\"for x in iter\"\n syntax used in construction of for-loops. In particular, \niter\n can be \na:b\n, where \na\n \n \nb\n are integer-valued expressions; or array/tuple-valued expression.\n\n\nprop\n is boolean-valued expression for proposition to be checked for arguments in specified ranges (see Examples below).\n\n\n\n\nDetails\n\n\nCode constructs a sequence of for-loops and checks that proposition evaluates to \ntrue\n for all values of variables specified. Equivalently, test is performed over cartesian product of ranges of variables.\n\n\nLoops are generated from \nargument_data\n inductively: from outer-loop to inner-loop. If range of a variable depends on other variables, then their ranges must be defined in \nargument_data\n earlier.\n\n\nExamples\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n-\n1\n:\n1\n,\n \nx\n*\n(\nx\n-\n1\n)\n*\n(\nx\n+\n1\n)\n \n==\n \n0\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n-\n1\n:\n1\n,\nx\n \n*\n \n(\nx\n \n-\n \n1\n)\n \n*\n \n(\nx\n \n+\n \n1\n)\n \n==\n \n0\n)\n\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n-\n1\n:\n1\n,\n \nx\n*\n(\nx\n-\n2\n)\n*\n(\nx\n+\n1\n)\n \n==\n \n0\n\n\nTest\n \nFailed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n-\n1\n:\n1\n,\nx\n \n*\n \n(\nx\n \n-\n \n2\n)\n \n*\n \n(\nx\n \n+\n \n1\n)\n \n==\n \n0\n)\n\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n[\n0\n,\n1\n,\n2\n],\n \ny\n \nin\n \nx\n:\n4\n,\n \n(\ny\n+\n4\n2\n*\nx\n)\n==\ntrue\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n[\n0\n,\n1\n,\n2\n],\ny\n \nin\n \nx\n:\n4\n,(\ny\n \n+\n \n4\n \n \n2\nx\n)\n \n==\n \ntrue\n)\n\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n(\n1\n-\n1\n,\n0\n+\n1\n,\nsqrt\n(\n4\n)),\n \ny\n \nin\n \nx\n:\n4\n,\n \n(\ny\n+\n4\n2\n*\nx\n)\n==\ntrue\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n(\n1\n \n-\n \n1\n,\n0\n \n+\n \n1\n,\nsqrt\n(\n4\n)),\ny\n \nin\n \nx\n:\n4\n,(\ny\n \n+\n \n4\n \n \n2\nx\n)\n \n==\n \ntrue\n)\n\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n[\na\n,\nb\n],\n \ny\n \nin\n \n[\nz\n,\nw\n],\n \nx\n*\ny\n \nin\n \nSet\n([\naz\n,\naw\n,\nbz\n,\nbw\n])\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n[\na\n,\nb\n],\ny\n \nin\n \n[\nz\n,\nw\n],\nx\n \n*\n \ny\n \nin\n \nSet\n([\naz\n,\naw\n,\nbz\n,\nbw\n]))\n\n\n\n# Bad design: throws UndefVarError: x not defined, because outer loop for y variable refers to the value of x coming after.\n\n\njulia\n \n@test_forall\n \ny\n \nin\n \nx\n:\n4\n,\nx\n \nin\n \n0\n:\n2\n,\n \n(\ny\n+\n4\n2\n*\nx\n)\n==\ntrue\n\n\nError\n \nDuring\n \nTest\n\n  \nTest\n \nthrew\n \nan\n \nexception\n \nof\n \ntype\n \nUndefVarError\n\n  \nExpression\n:\n \n(\ny\n \nin\n \nx\n:\n4\n,\nx\n \nin\n \n0\n:\n2\n,(\ny\n \n+\n \n4\n \n \n2\nx\n)\n \n==\n \ntrue\n)\n\n  \nUndefVarError\n:\n \nx\n \nnot\n \ndefined\n\n\n\n\n\n\nsource", 
            "title": "Test-forall"
        }, 
        {
            "location": "/macros/test-formany/", 
            "text": "#\n\n\nCheckers.@test_formany\n \n \nMacro\n.\n\n\n@test_formany [ntests = 100] [maxtests = 1000] [logto = \n] [argument_data, proposition]\n\n\n\n\n\nTakes proposition depending on some variables, generates sample of their values and tests the proposition. Returns \nPass\n if proposition holds for all values in the sample, \nFail\n if proposition does not hold for some value, and \nError\n if a part of code could not be evaluated.\n\n\nArguments\n\n\nMacro accepts a tuple of expressions that describe either statement of a test or specify optional keyword arguments.\n\n\nStatement of a test must be a sequence of comma-separated expressions, where all but last expressions are read as \nargument_data\n and last statement is \nproposition\n depending on these arguments.\n\n\n\n\nargument_data\n consists of arbitrarily many expressions containing\n\n\n\n\ninformation about variables, their types and conditions on them. Expressions must have one of the following forms:\n\n\n\n\na\nx::T\nb\n or \na\nx::T\nb\n, where middle variable \nx\n must be a symbol;\n\n\n\n\nT\n  must be a type; bounds \na\n \n \nb\n can be arbitrary expressions;\n\n\n\n\na\nx::T\nb\n, \na\nx::T\nb\n, \na\nx::T\nb\n or \na\nx::T\nb\n,\n\n\n\n\nsimilar to the one above;\n\n\n\n\nshorthand \nx\n instead of \nx::T\n may be used, e.g. \na\nx\nb\n,\n\n\n\n\nthen type of variable defaults to \nFloat64\n.\n\n\n\n\n\n\nproposition\n: is the expression to be tested. Two types of propositions are allowed:\n\n\n\n\nproposition\n of form \ncondition--\nstatement\n, where \ncondition\n and\n\n\n\n\nstatement\n are boolean-valued expressions\n\n\n\n\nproposition\n is boolean-valued expression itself\n\n\n\n\n\n\n\n\nOptional keyword arguments include the following:\n\n\n\n\nntests = 100\n: number of tests that must be performed.\n\n\nmaxtests = 1000\n: maximal number of attempts to generate arguments\n\n\n\n\nsatisfying \ncondition\n\n\n\n\nlogto = \"path_to_file\"\n: if provided then parsed as a path to file,\n\n\n\n\nwhere log of tests will be recorded.\n\n\nDescription\n\n\nMacro @test_formany is a test that attempts to generate sample of argument values of size \nntests\n satisfying the \ncondition\n if it is given. Then it checks whether the proposition holds for all elements in the sample. If number of attempts exceeds \nmaxtests\n parameter before at least \nntests\n values for arguments are generated, macro gives output \nBase.Test.Error\n.\n\n\nIf \nproposition\n is of form \ncondition--\nstatement\n (see arguments list), then test checks whether implication holds. Namely, the test passes if whenever \ncondition\n evaluates to \ntrue\n for generated argument values, then \nstatement\n also evaluates to \ntrue\n.\n\n\nIf \nproposition\n is just a boolean-valued expression, code simply checks whether \nprop\n holds for generated values.\n\n\nSome caution is required to avoid vacuous conditions. If test is unable to generate values satisfying the \ncondition\n after \nmaxtests\n attempts, output of the test is Base.Test.Error as mentioned before.\n\n\nDefault for optional keyword arguments is the following: \nntests = 100, maxtests = 1000\n. If only \nntests\n parameter is specified, \nmaxtests = 10*ntests\n. If \nlogto = \"path_to_file\"\n is given, log of test will be written to corresponding file,for example:\n\n\n\n\n@test_formany ntests = 10 maxtests = 1000  logto =  \"./test_log.csv\" 1\nx::Float32\n10, proposition\n\n\n@test_formany ntests = 50 logto = \"./test_log.csv\" 1\nx\n10, proposition\n ## maxtests = 500\n\n\n@test_formany logto = \"./test_log.csv\" 1\nx\nInf, proposition\n ## ntests = 100; maxtests = 1000\n\n\n@test_formany ntests = 50 maxtests = 1000 1\nx\n10, proposition\n ## not logged\n\n\n@test_formany 1\nx::Int32\nInf, proposition logto = \"./test_log.csv\" maxtests = 1000 ntests = 10\n ## order is not important\n\n\n\n\nExamples\n\n\njulia\n \n@test_formany\n \n100\nx\n::\nFloat64\n10\n,\n \nx\n+\n10\ny\n::\nFloat64\n1000\n,\n \ny\n-\n5\nz\n::\nFloat64\nInf\n,\n \nz\nx\n+\n5\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n100\n \n \nx\n::\nFloat64\n \n \n10\n,\nx\n \n+\n \n10\n \n \ny\n::\nFloat64\n \n \n1000\n,\ny\n \n-\n \n5\n \n \nz\n::\nFloat64\n \n \nInf\n,\nz\n \n \nx\n \n+\n \n5\n)),)\n\n\n\njulia\n \n@test_formany\n \nntests\n \n=\n \n1000\n \n100\nx\n::\nFloat64\n10\n,\n \nx\n+\n10\ny\n::\nFloat64\n1000\n,\n \ny\n-\n5\nz\n::\nFloat64\nInf\n,\n \nz\nx\n+\n6\n\n\nString\n[\nx = 25.18875813550991\n,\ny = 35.192306691353075\n,\nz = 31.183953098939906\n]\n\n\nTest\n \nFailed\n\n  \nExpression\n:\n \n(\n:\n(\nntests\n \n=\n \n1000\n),\n:\n((\n100\n \n \nx\n::\nFloat64\n \n \n10\n,\nx\n \n+\n \n10\n \n \ny\n::\nFloat64\n \n \n1000\n,\ny\n \n-\n \n5\n \n \nz\n::\nFloat64\n \n \nInf\n,\nz\n \n \nx\n \n+\n \n6\n)))\n\n\n\n## example of bad design for generators:\n\n\njulia\n \n@test_formany\n \n-\n1000\nx\n::\nFloat64\n1000\n,\n \nx\n999\n--\nx\n+\n1\n1000\n\n\nError\n \nDuring\n \nTest\n\n  \nTest\n \nthrew\n \nan\n \nexception\n \nof\n \ntype\n \nErrorException\n\n  \nExpression\n:\n \n(\n:\n((\n-\n1000\n \n \nx\n::\nFloat64\n \n \n1000\n,\n$\n(\nExpr\n(\n:--\n,\n \n:\n(\nx\n \n \n999\n),\n \n:\n(\nx\n \n+\n \n1\n \n \n1000\n))))),)\n\n  \nFound\n \nonly\n \n1\n/\n100\n \nvalues\n \nsatisfying\n \ngiven\n \ncondition\n.\n\n\n\n## log is increasing\n\n\njulia\n \n@test_formany\n \nInf\nx\n::\nFloat64\n0\n,\nInf\ny\n::\nFloat64\n0\n,\n \nx\ny\n--\nlog\n(\nx\n)\nlog\n(\ny\n)\n \nntests\n \n=\n \n1000\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\nInf\n \n \nx\n::\nFloat64\n \n \n0\n,\nInf\n \n \ny\n::\nFloat64\n \n \n0\n,\n$\n(\nExpr\n(\n:--\n,\n \n:\n(\nx\n \n \ny\n),\n \n:\n(\nlog\n(\nx\n)\n \n \nlog\n(\ny\n)))))),\n:\n(\nntests\n \n=\n \n1000\n))\n\n\n\n## f(x) = x^3 is not convex on [-100,100]\n\n\njulia\n \n@test_formany\n \n0\na\n1\n,\n-\n100\nx\n100\n,\n-\n100\ny\n100\n,(\na\n*\nx\n+\n(\n1\n-\na\n)\n*\ny\n)\n^\n3\na\n*\nx\n^\n3\n+\n(\n1\n-\na\n)\n*\ny\n^\n3\n\n\nString\n[\na = 0.39535367198058546\n,\nx = -13.538004569422625\n,\ny = 0.8504731053549079\n]\n\n\nTest\n \nFailed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \na\n \n \n1\n,\n-\n100\n \n \nx\n \n \n100\n,\n-\n100\n \n \ny\n \n \n100\n,(\na\n \n*\n \nx\n \n+\n \n(\n1\n \n-\n \na\n)\n \n*\n \ny\n)\n \n^\n \n3\n \n \na\n \n*\n \nx\n \n^\n \n3\n \n+\n \n(\n1\n \n-\n \na\n)\n \n*\n \ny\n \n^\n \n3\n)),)\n\n\n\n## f(x) = x^3 is convex on [-100,100]\n\n\njulia\n \n@test_formany\n \n0\na\n1\n,\n0\nx\n100\n,\n0\ny\n100\n,\n \n(\na\n*\nx\n+\n(\n1\n-\na\n)\n*\ny\n)\n^\n3\n=\na\n*\nx\n^\n3\n+\n(\n1\n-\na\n)\n*\ny\n^\n3\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \na\n \n \n1\n,\n0\n \n \nx\n \n \n100\n,\n0\n \n \ny\n \n \n100\n,(\na\n \n*\n \nx\n \n+\n \n(\n1\n \n-\n \na\n)\n \n*\n \ny\n)\n \n^\n \n3\n \n=\n \na\n \n*\n \nx\n \n^\n \n3\n \n+\n \n(\n1\n \n-\n \na\n)\n \n*\n \ny\n \n^\n \n3\n)),)\n\n\n\n## Cobb-Douglas utility function is concave\n\n\njulia\n \nfunction\n \nrespects_concavity\n(\nf\n,\nt\n,\nx1\n,\nx2\n)\n\n                  \nf\n(\nt\n*\nx1\n+\n(\n1\n-\nt\n)\n*\nx2\n)\n \n \nt\n \n*\n \nf\n(\nx1\n)\n \n+\n \n(\n1\n-\nt\n)\n \n*\n \nf\n(\nx2\n)\n\n              \nend\n\n\n\njulia\n \nfunction\n \nrespects_weak_concavity\n(\nf\n,\nt\n,\nx1\n,\nx2\n)\n\n                  \nf\n(\nt\n*\nx1\n+\n(\n1\n-\nt\n)\n*\nx2\n)\n \n=\n \nt\n \n*\n \nf\n(\nx1\n)\n \n+\n \n(\n1\n-\nt\n)\n \n*\n \nf\n(\nx2\n)\n\n              \nend\n\n\n\njulia\n \nfunction\n \ncobb_douglas\n(\na\n,\nx\n)\n\n                  \nprod\n(\nx\n.^\na\n)\n\n              \nend\n\n\n\n# This passes the @test_formany, since probability of discovering a counter-example with a = .5 is zero.\n\n\njulia\n \n@test_formany\n \n0\nt\n1\n,\n \n0\na\n1\n,\n \n1\nx1\n10\n,\n \n1\nx2\n10\n,\n \n1\ny1\n10\n,\n \n1\ny2\n10\n,\nrespects_concavity\n(\nx\n \n-\n \ncobb_douglas\n([\na\n,\n1\n-\na\n],\nx\n),\nt\n,[\nx1\n,\ny1\n],[\nx2\n,\ny2\n])\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nt\n \n \n1\n,\n0\n \n \na\n \n \n1\n,\n1\n \n \nx1\n \n \n10\n,\n1\n \n \nx2\n \n \n10\n,\n1\n \n \ny1\n \n \n10\n,\n1\n \n \ny2\n \n \n10\n,\nrespects_concavity\n((\nx\n-\nbegin\n  \n# REPL[5], line 1:\n\n                    \ncobb_douglas\n([\na\n,\n1\n \n-\n \na\n],\nx\n)\n\n                \nend\n),\nt\n,[\nx1\n,\ny1\n],[\nx2\n,\ny2\n]))),)\n\n\n\njulia\n \n@test_formany\n \n0\nt\n1\n,\n \n0\na\n1\n,\n \n1\nx1\n10\n,\n \n1\nx2\n10\n,\n \n1\ny1\n10\n,\n \n1\ny2\n10\n,\nrespects_weak_concavity\n(\nx\n \n-\n \ncobb_douglas\n([\na\n,\n1\n-\na\n],\nx\n),\nt\n,[\nx1\n,\ny1\n],[\nx2\n,\ny2\n])\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nt\n \n \n1\n,\n0\n \n \na\n \n \n1\n,\n1\n \n \nx1\n \n \n10\n,\n1\n \n \nx2\n \n \n10\n,\n1\n \n \ny1\n \n \n10\n,\n1\n \n \ny2\n \n \n10\n,\nrespects_weak_concavity\n((\nx\n-\nbegin\n  \n# REPL[6], line 1:\n\n                    \ncobb_douglas\n([\na\n,\n1\n \n-\n \na\n],\nx\n)\n\n                \nend\n),\nt\n,[\nx1\n,\ny1\n],[\nx2\n,\ny2\n]))),)\n\n\n\n## handling errors\n\n\njulia\n \n@test_formany\n \n-\n1\nx\n1\n,\n \nabs\n(\nlog\n(\nx\n))\n0\n\n\nError\n \nDuring\n \nTest\n\n  \nTest\n \nthrew\n \nan\n \nexception\n \nof\n \ntype\n \nDomainError\n\n  \nExpression\n:\n \n(\n:\n((\n-\n1\n \n \nx\n \n \n1\n,\nabs\n(\nlog\n(\nx\n))\n \n \n0\n)),)\n\n  \nDomainError\n\n\n\n\n\n\nsource", 
            "title": "Test-formany"
        }, 
        {
            "location": "/macros/test-exists/", 
            "text": "#\n\n\nCheckers.@test_exists\n \n \nMacro\n.\n\n\n@test_exists [ntests = 100][maxtests = 1000][logto = \n][argument_data, prop]\n\n\n\n\n\nGenerates sample of values for arguments in proposition. Returns \nPass\n if proposition holds for at least one value in the sample, \nFail\n if proposition does not hold for any values, and \nError\n if a part of code could not be evaluated. \nError\n is given if after \nmaxtests\n attempts to generate argument values, number of arguments satisfying \ncondition\n part of \nprop\n is less than \nntests\n.\n\n\nDescription\n\n\nSimilar to \n@test_formany\n, see it's documentation for details.\n\n\nExamples\n\n\njulia\n \n@test_exists\n \nntests\n \n=\n \n1000\n \n-\n10\nx\n10\n,\n \nx\n^\n2\n99\n\n\nString\n[\nx = -9.966560160994264\n]\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n(\nntests\n \n=\n \n1000\n),\n:\n((\n-\n10\n \n \nx\n \n \n10\n,\nx\n \n^\n \n2\n \n \n99\n)))\n\n\n\n## values are generated successively in the oder x-\ny-\nz, they satisfy x\ny\nz automatically\n\n\njulia\n \n@test_exists\n \n0\nx\n2\n*\npi\n,\n \nx\ny\n2\n*\npi\n,\n \ny\nz\n2\n*\npi\n,\n \nsin\n(\nx\n)\nsin\n(\ny\n)\nsin\n(\nz\n)\n\n\nString\n[\nx = 5.787034350107664\n,\ny = 6.23560263220101\n,\nz = 6.26802436856299\n]\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nx\n \n \n2\npi\n,\nx\n \n \ny\n \n \n2\npi\n,\ny\n \n \nz\n \n \n2\npi\n,\nsin\n(\nx\n)\n \n \nsin\n(\ny\n)\n \n \nsin\n(\nz\n))),)\n\n\n\n## values are generated independently, the statement is checked only for those that satisfy x\ny\nz\n\n\njulia\n \n@test_exists\n \n0\nx\n2\n*\npi\n,\n \n0\ny\n2\n*\npi\n,\n \n0\nz\n2\n*\npi\n,\n \nx\ny\nz\n \n--\n \nsin\n(\nx\n)\nsin\n(\ny\n)\nsin\n(\nz\n)\n \nntests\n \n=\n \n1000\n\n\nString\n[\nx = 0.3082312611033726\n,\ny = 0.49557010329840206\n,\nz = 2.5966119472766076\n]\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nx\n \n \n2\npi\n,\n0\n \n \ny\n \n \n2\npi\n,\n0\n \n \nz\n \n \n2\npi\n,\n$\n(\nExpr\n(\n:--\n,\n \n:\n(\nx\n \n \ny\n \n \nz\n),\n \n:\n(\nsin\n(\nx\n)\n \n \nsin\n(\ny\n)\n \n \nsin\n(\nz\n)))))),\n:\n(\nntests\n \n=\n \n1000\n))\n\n\n\n## Gives Error, because condition is too restrictive\n\n\n@test_exists\n \n0\nx\n1000\n,\n \nx\n990\n \n--\n \nx\n999.9\n \nntests\n \n=\n \n100\n\n\nError\n \nDuring\n \nTest\n\n  \nTest\n \nthrew\n \nan\n \nexception\n \nof\n \ntype\n \nErrorException\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nx\n \n \n1000\n,\n$\n(\nExpr\n(\n:--\n,\n \n:\n(\nx\n \n \n990\n),\n \n:\n(\nx\n \n \n999.9\n))))),\n:\n(\nntests\n \n=\n \n100\n))\n\n  \nFound\n \nonly\n \n14\n/\n100\n \nvalues\n \nsatisfying\n \ngiven\n \ncondition\n.\n\n\n\n\n\n\nsource", 
            "title": "Test-exists"
        }
    ]
}