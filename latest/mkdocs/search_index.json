{
    "docs": [
        {
            "location": "/", 
            "text": "Checkers.jl Documentation\n\n\n\n\nTesting Macros\n\n\n\n\nIndex\n\n\n\n\nCheckers.@test_exists\n\n\nCheckers.@test_forall\n\n\nCheckers.@test_formany", 
            "title": "Home"
        }, 
        {
            "location": "/#checkersjl-documentation", 
            "text": "", 
            "title": "Checkers.jl Documentation"
        }, 
        {
            "location": "/#testing-macros", 
            "text": "", 
            "title": "Testing Macros"
        }, 
        {
            "location": "/#index", 
            "text": "Checkers.@test_exists  Checkers.@test_forall  Checkers.@test_formany", 
            "title": "Index"
        }, 
        {
            "location": "/macros/test-forall/", 
            "text": "#\n\n\nCheckers.@test_forall\n \n \nMacro\n.\n\n\n@test_forall argument_data, prop\n\n\n\n\n\nCheck statement of proposition over all tuples of values of variables, specified in \nargument_data\n. Generate Pass/Fail/Error output for Base.Test. \n\n\nArguments\n\n\n\n\nargument_data\n: comma separated expression with arbitrarily many statements, containing information about ranges of variables. Statements must have form \nx in iter\n, where \nx\n is symbol and \niter\n is any expression valid in \n\"for x in iter\"\n syntax used in construction of for-loops. In particular, \niter\n can be \na:b\n, where \na\n \n \nb\n are integer-valued expressions; or array/tuple-valued expression.\n\n\nprop\n is boolean-valued expression for proposition to be checked for arguments in specified ranges (see Examples below).\n\n\n\n\nDetails\n\n\nCode constructs a sequence of for-loops and checks that proposition evaluates to \ntrue\n for all values of variables specified. Equivalently, test is performed over cartesian product of ranges of variables.\n\n\nLoops are generated from \nargument_data\n inductively: from outer-loop to inner-loop. If range of a variable depends on other variables, then their ranges must be defined in \nargument_data\n earlier.\n\n\nExamples\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n-\n1\n:\n1\n,\n \nx\n*\n(\nx\n-\n1\n)\n*\n(\nx\n+\n1\n)\n \n==\n \n0\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n-\n1\n:\n1\n,\nx\n \n*\n \n(\nx\n \n-\n \n1\n)\n \n*\n \n(\nx\n \n+\n \n1\n)\n \n==\n \n0\n)\n\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n-\n1\n:\n1\n,\n \nx\n*\n(\nx\n-\n2\n)\n*\n(\nx\n+\n1\n)\n \n==\n \n0\n\n\nTest\n \nFailed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n-\n1\n:\n1\n,\nx\n \n*\n \n(\nx\n \n-\n \n2\n)\n \n*\n \n(\nx\n \n+\n \n1\n)\n \n==\n \n0\n)\n\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n[\n0\n,\n1\n,\n2\n],\n \ny\n \nin\n \nx\n:\n4\n,\n \n(\ny\n+\n4\n2\n*\nx\n)\n==\ntrue\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n[\n0\n,\n1\n,\n2\n],\ny\n \nin\n \nx\n:\n4\n,(\ny\n \n+\n \n4\n \n \n2\nx\n)\n \n==\n \ntrue\n)\n\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n(\n1\n-\n1\n,\n0\n+\n1\n,\nsqrt\n(\n4\n)),\n \ny\n \nin\n \nx\n:\n4\n,\n \n(\ny\n+\n4\n2\n*\nx\n)\n==\ntrue\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n(\n1\n \n-\n \n1\n,\n0\n \n+\n \n1\n,\nsqrt\n(\n4\n)),\ny\n \nin\n \nx\n:\n4\n,(\ny\n \n+\n \n4\n \n \n2\nx\n)\n \n==\n \ntrue\n)\n\n\n\njulia\n \n@test_forall\n \nx\n \nin\n \n[\na\n,\nb\n],\n \ny\n \nin\n \n[\nz\n,\nw\n],\n \nx\n*\ny\n \nin\n \nSet\n([\naz\n,\naw\n,\nbz\n,\nbw\n])\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\nx\n \nin\n \n[\na\n,\nb\n],\ny\n \nin\n \n[\nz\n,\nw\n],\nx\n \n*\n \ny\n \nin\n \nSet\n([\naz\n,\naw\n,\nbz\n,\nbw\n]))\n\n\n\n# Bad design: throws UndefVarError: x not defined, because outer loop for y variable refers to the value of x coming after.\n\n\njulia\n \n@test_forall\n \ny\n \nin\n \nx\n:\n4\n,\nx\n \nin\n \n0\n:\n2\n,\n \n(\ny\n+\n4\n2\n*\nx\n)\n==\ntrue\n\n\nError\n \nDuring\n \nTest\n\n  \nTest\n \nthrew\n \nan\n \nexception\n \nof\n \ntype\n \nUndefVarError\n\n  \nExpression\n:\n \n(\ny\n \nin\n \nx\n:\n4\n,\nx\n \nin\n \n0\n:\n2\n,(\ny\n \n+\n \n4\n \n \n2\nx\n)\n \n==\n \ntrue\n)\n\n  \nUndefVarError\n:\n \nx\n \nnot\n \ndefined\n\n\n\n\n\n\nsource", 
            "title": "Test-forall"
        }, 
        {
            "location": "/macros/test-forall/#examples", 
            "text": "julia   @test_forall   x   in   - 1 : 1 ,   x * ( x - 1 ) * ( x + 1 )   ==   0  Test   Passed \n   Expression :   ( x   in   - 1 : 1 , x   *   ( x   -   1 )   *   ( x   +   1 )   ==   0 )  julia   @test_forall   x   in   - 1 : 1 ,   x * ( x - 2 ) * ( x + 1 )   ==   0  Test   Failed \n   Expression :   ( x   in   - 1 : 1 , x   *   ( x   -   2 )   *   ( x   +   1 )   ==   0 )  julia   @test_forall   x   in   [ 0 , 1 , 2 ],   y   in   x : 4 ,   ( y + 4 2 * x ) == true  Test   Passed \n   Expression :   ( x   in   [ 0 , 1 , 2 ], y   in   x : 4 ,( y   +   4     2 x )   ==   true )  julia   @test_forall   x   in   ( 1 - 1 , 0 + 1 , sqrt ( 4 )),   y   in   x : 4 ,   ( y + 4 2 * x ) == true  Test   Passed \n   Expression :   ( x   in   ( 1   -   1 , 0   +   1 , sqrt ( 4 )), y   in   x : 4 ,( y   +   4     2 x )   ==   true )  julia   @test_forall   x   in   [ a , b ],   y   in   [ z , w ],   x * y   in   Set ([ az , aw , bz , bw ])  Test   Passed \n   Expression :   ( x   in   [ a , b ], y   in   [ z , w ], x   *   y   in   Set ([ az , aw , bz , bw ]))  # Bad design: throws UndefVarError: x not defined, because outer loop for y variable refers to the value of x coming after.  julia   @test_forall   y   in   x : 4 , x   in   0 : 2 ,   ( y + 4 2 * x ) == true  Error   During   Test \n   Test   threw   an   exception   of   type   UndefVarError \n   Expression :   ( y   in   x : 4 , x   in   0 : 2 ,( y   +   4     2 x )   ==   true ) \n   UndefVarError :   x   not   defined   source", 
            "title": "Examples"
        }, 
        {
            "location": "/macros/test-formany/", 
            "text": "#\n\n\nCheckers.@test_formany\n \n \nMacro\n.\n\n\n@test_formany [ntests = 100] [maxtests = 1000] [logto = \n] [argument_data, proposition]\n\n\n\n\n\nTakes proposition depending on some variables, generates sample of their values and tests the proposition. Returns \nPass\n if proposition holds for all values in the sample, \nFail\n if proposition does not hold for some value, and \nError\n if a part of code could not be evaluated.\n\n\nArguments\n\n\nMacro accepts a tuple of expressions that describe either statement of a test or specify optional keyword arguments.\n\n\nStatement of a test must be a sequence of comma-separated expressions, where all but last expressions are read as \nargument_data\n and last statement is \nproposition\n depending on these arguments.\n\n\n\n\nargument_data\n consists of arbitrarily many expressions containing\n\n\n\n\ninformation about variables, their types and conditions on them. Expressions must have one of the following forms:\n\n\n\n\na\nx::T\nb\n or \na\nx::T\nb\n, where middle variable \nx\n must be a symbol;\n\n\n\n\nT\n  must be a type; bounds \na\n \n \nb\n can be arbitrary expressions;\n\n\n\n\na\nx::T\nb\n, \na\nx::T\nb\n, \na\nx::T\nb\n or \na\nx::T\nb\n,\n\n\n\n\nsimilar to the one above;\n\n\n\n\nshorthand \nx\n instead of \nx::T\n may be used, e.g. \na\nx\nb\n,\n\n\n\n\nthen type of variable defaults to \nFloat64\n.\n\n\n\n\n\n\nproposition\n: is the expression to be tested. Two types of propositions are allowed:\n\n\n\n\nproposition\n of form \ncondition--\nstatement\n, where \ncondition\n and\n\n\n\n\nstatement\n are boolean-valued expressions\n\n\n\n\nproposition\n is boolean-valued expression itself\n\n\n\n\n\n\n\n\nOptional keyword arguments include the following:\n\n\n\n\nntests = 100\n: number of tests that must be performed.\n\n\nmaxtests = 1000\n: maximal number of attempts to generate arguments\n\n\n\n\nsatisfying \ncondition\n\n\n\n\nlogto = \"path_to_file\"\n: if provided then parsed as a path to file,\n\n\n\n\nwhere log of tests will be recorded.\n\n\nDescription\n\n\nMacro @test_formany is a test that attempts to generate sample of argument values of size \nntests\n satisfying the \ncondition\n if it is given. Then it checks whether the proposition holds for all elements in the sample. If number of attempts exceeds \nmaxtests\n parameter before at least \nntests\n values for arguments are generated, macro gives output \nBase.Test.Error\n.\n\n\nIf \nproposition\n is of form \ncondition--\nstatement\n (see arguments list), then test checks whether implication holds. Namely, the test passes if whenever \ncondition\n evaluates to \ntrue\n for generated argument values, then \nstatement\n also evaluates to \ntrue\n.\n\n\nIf \nproposition\n is just a boolean-valued expression, code simply checks whether \nprop\n holds for generated values.\n\n\nSome caution is required to avoid vacuous conditions. If test is unable to generate values satisfying the \ncondition\n after \nmaxtests\n attempts, output of the test is Base.Test.Error as mentioned before.\n\n\nDefault for optional keyword arguments is the following: \nntests = 100, maxtests = 1000\n. If only \nntests\n parameter is specified, \nmaxtests = 10*ntests\n. If \nlogto = \"path_to_file\"\n is given, log of test will be written to corresponding file,for example:\n\n\n\n\n@test_formany ntests = 10 maxtests = 1000  logto =  \"./test_log.csv\" 1\nx::Float32\n10, proposition\n\n\n@test_formany ntests = 50 logto = \"./test_log.csv\" 1\nx\n10, proposition\n ## maxtests = 500\n\n\n@test_formany logto = \"./test_log.csv\" 1\nx\nInf, proposition\n ## ntests = 100; maxtests = 1000\n\n\n@test_formany ntests = 50 maxtests = 1000 1\nx\n10, proposition\n ## not logged\n\n\n@test_formany 1\nx::Int32\nInf, proposition logto = \"./test_log.csv\" maxtests = 1000 ntests = 10\n ## order is not important\n\n\n\n\nExamples\n\n\njulia\n \n@test_formany\n \n100\nx\n::\nFloat64\n10\n,\n \nx\n+\n10\ny\n::\nFloat64\n1000\n,\n \ny\n-\n5\nz\n::\nFloat64\nInf\n,\n \nz\nx\n+\n5\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n100\n \n \nx\n::\nFloat64\n \n \n10\n,\nx\n \n+\n \n10\n \n \ny\n::\nFloat64\n \n \n1000\n,\ny\n \n-\n \n5\n \n \nz\n::\nFloat64\n \n \nInf\n,\nz\n \n \nx\n \n+\n \n5\n)),)\n\n\n\njulia\n \n@test_formany\n \nntests\n \n=\n \n1000\n \n100\nx\n::\nFloat64\n10\n,\n \nx\n+\n10\ny\n::\nFloat64\n1000\n,\n \ny\n-\n5\nz\n::\nFloat64\nInf\n,\n \nz\nx\n+\n6\n\n\nString\n[\nx = 25.18875813550991\n,\ny = 35.192306691353075\n,\nz = 31.183953098939906\n]\n\n\nTest\n \nFailed\n\n  \nExpression\n:\n \n(\n:\n(\nntests\n \n=\n \n1000\n),\n:\n((\n100\n \n \nx\n::\nFloat64\n \n \n10\n,\nx\n \n+\n \n10\n \n \ny\n::\nFloat64\n \n \n1000\n,\ny\n \n-\n \n5\n \n \nz\n::\nFloat64\n \n \nInf\n,\nz\n \n \nx\n \n+\n \n6\n)))\n\n\n\n## example of bad design for generators:\n\n\njulia\n \n@test_formany\n \n-\n1000\nx\n::\nFloat64\n1000\n,\n \nx\n999\n--\nx\n+\n1\n1000\n\n\nError\n \nDuring\n \nTest\n\n  \nTest\n \nthrew\n \nan\n \nexception\n \nof\n \ntype\n \nErrorException\n\n  \nExpression\n:\n \n(\n:\n((\n-\n1000\n \n \nx\n::\nFloat64\n \n \n1000\n,\n$\n(\nExpr\n(\n:--\n,\n \n:\n(\nx\n \n \n999\n),\n \n:\n(\nx\n \n+\n \n1\n \n \n1000\n))))),)\n\n  \nFound\n \nonly\n \n1\n/\n100\n \nvalues\n \nsatisfying\n \ngiven\n \ncondition\n.\n\n\n\n## log is increasing\n\n\njulia\n \n@test_formany\n \nInf\nx\n::\nFloat64\n0\n,\nInf\ny\n::\nFloat64\n0\n,\n \nx\ny\n--\nlog\n(\nx\n)\nlog\n(\ny\n)\n \nntests\n \n=\n \n1000\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\nInf\n \n \nx\n::\nFloat64\n \n \n0\n,\nInf\n \n \ny\n::\nFloat64\n \n \n0\n,\n$\n(\nExpr\n(\n:--\n,\n \n:\n(\nx\n \n \ny\n),\n \n:\n(\nlog\n(\nx\n)\n \n \nlog\n(\ny\n)))))),\n:\n(\nntests\n \n=\n \n1000\n))\n\n\n\n## f(x) = x^3 is not convex on [-100,100]\n\n\njulia\n \n@test_formany\n \n0\na\n1\n,\n-\n100\nx\n100\n,\n-\n100\ny\n100\n,(\na\n*\nx\n+\n(\n1\n-\na\n)\n*\ny\n)\n^\n3\na\n*\nx\n^\n3\n+\n(\n1\n-\na\n)\n*\ny\n^\n3\n\n\nString\n[\na = 0.39535367198058546\n,\nx = -13.538004569422625\n,\ny = 0.8504731053549079\n]\n\n\nTest\n \nFailed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \na\n \n \n1\n,\n-\n100\n \n \nx\n \n \n100\n,\n-\n100\n \n \ny\n \n \n100\n,(\na\n \n*\n \nx\n \n+\n \n(\n1\n \n-\n \na\n)\n \n*\n \ny\n)\n \n^\n \n3\n \n \na\n \n*\n \nx\n \n^\n \n3\n \n+\n \n(\n1\n \n-\n \na\n)\n \n*\n \ny\n \n^\n \n3\n)),)\n\n\n\n## f(x) = x^3 is convex on [-100,100]\n\n\njulia\n \n@test_formany\n \n0\na\n1\n,\n0\nx\n100\n,\n0\ny\n100\n,\n \n(\na\n*\nx\n+\n(\n1\n-\na\n)\n*\ny\n)\n^\n3\n=\na\n*\nx\n^\n3\n+\n(\n1\n-\na\n)\n*\ny\n^\n3\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \na\n \n \n1\n,\n0\n \n \nx\n \n \n100\n,\n0\n \n \ny\n \n \n100\n,(\na\n \n*\n \nx\n \n+\n \n(\n1\n \n-\n \na\n)\n \n*\n \ny\n)\n \n^\n \n3\n \n=\n \na\n \n*\n \nx\n \n^\n \n3\n \n+\n \n(\n1\n \n-\n \na\n)\n \n*\n \ny\n \n^\n \n3\n)),)\n\n\n\n## Cobb-Douglas utility function is concave\n\n\njulia\n \nfunction\n \nrespects_concavity\n(\nf\n,\nt\n,\nx1\n,\nx2\n)\n\n                  \nf\n(\nt\n*\nx1\n+\n(\n1\n-\nt\n)\n*\nx2\n)\n \n \nt\n \n*\n \nf\n(\nx1\n)\n \n+\n \n(\n1\n-\nt\n)\n \n*\n \nf\n(\nx2\n)\n\n              \nend\n\n\n\njulia\n \nfunction\n \nrespects_weak_concavity\n(\nf\n,\nt\n,\nx1\n,\nx2\n)\n\n                  \nf\n(\nt\n*\nx1\n+\n(\n1\n-\nt\n)\n*\nx2\n)\n \n=\n \nt\n \n*\n \nf\n(\nx1\n)\n \n+\n \n(\n1\n-\nt\n)\n \n*\n \nf\n(\nx2\n)\n\n              \nend\n\n\n\njulia\n \nfunction\n \ncobb_douglas\n(\na\n,\nx\n)\n\n                  \nprod\n(\nx\n.^\na\n)\n\n              \nend\n\n\n\n# This passes the @test_formany, since probability of discovering a counter-example with a = .5 is zero.\n\n\njulia\n \n@test_formany\n \n0\nt\n1\n,\n \n0\na\n1\n,\n \n1\nx1\n10\n,\n \n1\nx2\n10\n,\n \n1\ny1\n10\n,\n \n1\ny2\n10\n,\nrespects_concavity\n(\nx\n \n-\n \ncobb_douglas\n([\na\n,\n1\n-\na\n],\nx\n),\nt\n,[\nx1\n,\ny1\n],[\nx2\n,\ny2\n])\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nt\n \n \n1\n,\n0\n \n \na\n \n \n1\n,\n1\n \n \nx1\n \n \n10\n,\n1\n \n \nx2\n \n \n10\n,\n1\n \n \ny1\n \n \n10\n,\n1\n \n \ny2\n \n \n10\n,\nrespects_concavity\n((\nx\n-\nbegin\n  \n# REPL[5], line 1:\n\n                    \ncobb_douglas\n([\na\n,\n1\n \n-\n \na\n],\nx\n)\n\n                \nend\n),\nt\n,[\nx1\n,\ny1\n],[\nx2\n,\ny2\n]))),)\n\n\n\njulia\n \n@test_formany\n \n0\nt\n1\n,\n \n0\na\n1\n,\n \n1\nx1\n10\n,\n \n1\nx2\n10\n,\n \n1\ny1\n10\n,\n \n1\ny2\n10\n,\nrespects_weak_concavity\n(\nx\n \n-\n \ncobb_douglas\n([\na\n,\n1\n-\na\n],\nx\n),\nt\n,[\nx1\n,\ny1\n],[\nx2\n,\ny2\n])\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nt\n \n \n1\n,\n0\n \n \na\n \n \n1\n,\n1\n \n \nx1\n \n \n10\n,\n1\n \n \nx2\n \n \n10\n,\n1\n \n \ny1\n \n \n10\n,\n1\n \n \ny2\n \n \n10\n,\nrespects_weak_concavity\n((\nx\n-\nbegin\n  \n# REPL[6], line 1:\n\n                    \ncobb_douglas\n([\na\n,\n1\n \n-\n \na\n],\nx\n)\n\n                \nend\n),\nt\n,[\nx1\n,\ny1\n],[\nx2\n,\ny2\n]))),)\n\n\n\n## handling errors\n\n\njulia\n \n@test_formany\n \n-\n1\nx\n1\n,\n \nabs\n(\nlog\n(\nx\n))\n0\n\n\nError\n \nDuring\n \nTest\n\n  \nTest\n \nthrew\n \nan\n \nexception\n \nof\n \ntype\n \nDomainError\n\n  \nExpression\n:\n \n(\n:\n((\n-\n1\n \n \nx\n \n \n1\n,\nabs\n(\nlog\n(\nx\n))\n \n \n0\n)),)\n\n  \nDomainError\n\n\n\n\n\n\nsource", 
            "title": "Test-formany"
        }, 
        {
            "location": "/macros/test-exists/", 
            "text": "#\n\n\nCheckers.@test_exists\n \n \nMacro\n.\n\n\n@test_exists [ntests = 100][maxtests = 1000][logto = \n][argument_data, prop]\n\n\n\n\n\nGenerates sample of values for arguments in proposition. Returns \nPass\n if proposition holds for at least one value in the sample, \nFail\n if proposition does not hold for any values, and \nError\n if a part of code could not be evaluated. \nError\n is given if after \nmaxtests\n attempts to generate argument values, number of arguments satisfying \ncondition\n part of \nprop\n is less than \nntests\n.\n\n\nDescription\n\n\nSimilar to \n@test_formany\n, see it's documentation for details.\n\n\nExamples\n\n\njulia\n \n@test_exists\n \nntests\n \n=\n \n1000\n \n-\n10\nx\n10\n,\n \nx\n^\n2\n99\n\n\nString\n[\nx = -9.966560160994264\n]\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n(\nntests\n \n=\n \n1000\n),\n:\n((\n-\n10\n \n \nx\n \n \n10\n,\nx\n \n^\n \n2\n \n \n99\n)))\n\n\n\n## values are generated successively in the oder x-\ny-\nz, they satisfy x\ny\nz automatically\n\n\njulia\n \n@test_exists\n \n0\nx\n2\n*\npi\n,\n \nx\ny\n2\n*\npi\n,\n \ny\nz\n2\n*\npi\n,\n \nsin\n(\nx\n)\nsin\n(\ny\n)\nsin\n(\nz\n)\n\n\nString\n[\nx = 5.787034350107664\n,\ny = 6.23560263220101\n,\nz = 6.26802436856299\n]\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nx\n \n \n2\npi\n,\nx\n \n \ny\n \n \n2\npi\n,\ny\n \n \nz\n \n \n2\npi\n,\nsin\n(\nx\n)\n \n \nsin\n(\ny\n)\n \n \nsin\n(\nz\n))),)\n\n\n\n## values are generated independently, the statement is checked only for those that satisfy x\ny\nz\n\n\njulia\n \n@test_exists\n \n0\nx\n2\n*\npi\n,\n \n0\ny\n2\n*\npi\n,\n \n0\nz\n2\n*\npi\n,\n \nx\ny\nz\n \n--\n \nsin\n(\nx\n)\nsin\n(\ny\n)\nsin\n(\nz\n)\n \nntests\n \n=\n \n1000\n\n\nString\n[\nx = 0.3082312611033726\n,\ny = 0.49557010329840206\n,\nz = 2.5966119472766076\n]\n\n\nTest\n \nPassed\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nx\n \n \n2\npi\n,\n0\n \n \ny\n \n \n2\npi\n,\n0\n \n \nz\n \n \n2\npi\n,\n$\n(\nExpr\n(\n:--\n,\n \n:\n(\nx\n \n \ny\n \n \nz\n),\n \n:\n(\nsin\n(\nx\n)\n \n \nsin\n(\ny\n)\n \n \nsin\n(\nz\n)))))),\n:\n(\nntests\n \n=\n \n1000\n))\n\n\n\n## Gives Error, because condition is too restrictive\n\n\n@test_exists\n \n0\nx\n1000\n,\n \nx\n990\n \n--\n \nx\n999.9\n \nntests\n \n=\n \n100\n\n\nError\n \nDuring\n \nTest\n\n  \nTest\n \nthrew\n \nan\n \nexception\n \nof\n \ntype\n \nErrorException\n\n  \nExpression\n:\n \n(\n:\n((\n0\n \n \nx\n \n \n1000\n,\n$\n(\nExpr\n(\n:--\n,\n \n:\n(\nx\n \n \n990\n),\n \n:\n(\nx\n \n \n999.9\n))))),\n:\n(\nntests\n \n=\n \n100\n))\n\n  \nFound\n \nonly\n \n14\n/\n100\n \nvalues\n \nsatisfying\n \ngiven\n \ncondition\n.\n\n\n\n\n\n\nsource", 
            "title": "Test-exists"
        }
    ]
}